# -*- coding: utf-8 -*-
"""Marching_Simplex

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kd6g5MB-L5-uz4cCeeZAgaYi16y4JdPd
"""



""""
Adapted from https://github.com/antoniocastelofilho/marching_simplex/tree/master
""""



######## Importe das bibliotecas ######

import numpy as np
import math

######## Grid e Coordenadas ########


# Construção do vetor base para codificar as coordenadas do grid n-dim como índices lineares
def init_grid(n, division):
    base = np.zeros(n + 1, dtype=int)
    base[0] = 1
    for i in range(1, n + 1):
        base[i] = base[i - 1] * division[i - 1]
    return base



# Converte índice linear i de volta para as coordenadas da grade n-dim

def grid_coords(n, i, base):
    copy = i
    grid = np.zeros(n, dtype=int)
    for j in range(n - 1, 0, -1):
        aux = copy % base[j]
        grid[j] = (copy - aux) // base[j]
        copy = aux
    grid[0] = copy
    return grid


# Pega um número entre 0 e 2^n−1 e retorna a lista de bits representando o vértice
# Converte para as coordenadas (0 ou 1) de um vértice do hipercubo n-dim


def hypercube_coords(n, i):
    copy = i
    coords = np.zeros(n, dtype=int)
    for j in range(n - 1):
        coords[j] = copy % 2
        copy = (copy - coords[j]) // 2
    coords[n - 1] = copy
    return coords


# Escolha de qual perturbação aleatória usar para um vértice do hipercubo


def hypercube_pert(n, grid, coords, pert):
    pot = 1
    label = 0
    for i in range(n):
        p = abs(coords[i] - (grid[i] % 2))
        label += pot * p
        pot *= 2
    return pert[label]


# Constrói a coordenada real do vértice de um hipercubo da malha
def hypercube(n, first, delta, I, coords, pert):
    vhc = np.zeros(n)
    for i in range(n):
        vhc[i] = first[i] + (I[i] + coords[i]) * delta[i] + pert[i]
    return vhc

############### Geração de Vértices e Variedade ##############


# Aqui é gerado todos os 2^n vértices de um hipercubo da malha e avalia a função Func em cada um deles


def gen_vert(n, grid, pert, first, delta, func):
    vert = []
    fvert = []
    for i in range(2**n):
        coords = hypercube_coords(n, i)
        coord_pert = hypercube_pert(n, grid, coords, pert)
        vhc = hypercube(n, first, delta, grid, coords, coord_pert)
        vert.append(vhc)

        # Avalia a função e garante que seja um array 1D mesmo se escalar
        val = func(n, vhc)
        fvert.append(np.atleast_1d(val))

    return np.array(vert), np.array(fvert)


def get_vertex_manifold(n, k, face, vert, fvert):
    # m = número de vértices do k-simplexo (k+1)
    m = k + 1
    # Monta matriz A: primeira linha 1s, resto valores da função
    # FVert[Face[i]] deve ter tamanho (m-1)
    # Se k=1 (codim 1), m=2. FVert[x] tem tamanho 1. A é 2x2



    dim_f = fvert.shape[1] # Dimensão da imagem da função
    A = np.zeros((dim_f + 1, m), dtype=float)

    for i in range(m):
        A[0, i] = 1.0
        A[1:, i] = fvert[face[i]]

    b = np.zeros(dim_f + 1, dtype=float)
    b[0] = 1.0

    vertex = np.zeros(n, dtype=float)
    trans = 0

    # Resolve o sistema linear para obter os coeficientes baricêntricos
    try:
        lamb, residuals, rank, s = np.linalg.lstsq(A, b, rcond=None)
    except np.linalg.LinAlgError:
        return vertex, 0

    # Verifica se a solução é válida (coordenadas baricêntricas positivas)
    # Tolerância pequena para erros numéricos
    if np.all(lamb >= -1e-9):
        for i in range(m):
            vertex += lamb[i] * vert[face[i]]
        trans = 1

    return vertex, trans


########## Lógica Combinatória (Simplexos e Esqueleto) ########



# Constrói uma permutação a partir de uma lista f dizendo onde cada elemento deve ser inserido
def map_perm(n, f):
    # f é permutação 1-based
    F = [0] * n
    for i in range(1, n + 1):
        # f[i-1] pega o valor 1-based. pos é onde deve ser inserido (1-based)
        pos = f[i - 1]
        idx_pos = pos - 1 # índice 0-based para array F

        if F[idx_pos] == 0:
            F[idx_pos] = i
        else:

            for j in range(n - 1, idx_pos, -1):
                F[j] = F[j - 1]
            F[idx_pos] = i
    return F



# Ordem lexicográfica
def lexico(k, f):
    # f é lista de inteiros
    for i in range(k - 1):
        if f[i] >= f[i + 1]:
            return 0
    return 1



# Rotulagem binária
def gen_label_simplex(n, P):
    simp = [0] * (n + 1)
    # P contém valores 1..n.
    for i in range(1, n + 1):
        simp[i] = simp[i - 1] + 2**(P[i - 1] - 1)
    return simp



# Contagem dos elementos preservando a ordem crescente
def include(n, x, m, y):
    # x: array, n: tamanho usado de x
    # y: array, m: tamanho usado de y
    # Conta quantos elementos comuns existem mantendo ordem

    k_count = 0
    j = 0
    for i in range(n):
        # Avança j enquanto y[j] for menor que x[i]
        while j < m and y[j] < x[i]:
            j += 1

        if j < m and y[j] == x[i]:
            k_count += 1
    return k_count



######### Esqueleto combinatório ######

def skeleton(n, simp, k, n_vertex, facevertex):

    n_skel = [0] * (n - k + 1)
    n_skel[0] = n_vertex

    skel = [None] * (n - k + 1)
    skel[0] = [list(f) for f in facevertex]

    adj_skel = [None] * (n - k)

    # s representa a dim que estamos construindo
    for s in range(k + 1, n + 1):

        # Constrói grid combinatória para dimensão s
        divisionC = [n - s + i for i in range(1, s + 2)]
        base_c = init_grid(s + 1, divisionC)

        faces_simp = []
        faces_adj = []

        idx_skel = s - k
        n_skel[idx_skel] = 0

        total_perms = base_c[s + 1]

        for j in range(total_perms):
            C = grid_coords(s + 1, j, base_c)
            C1 = [x + 1 for x in C] # 1-based para Lexico e índices

            if lexico(s + 1, C1) == 1:
                # Mapeia para vértices do simplexo
                face = [simp[c - 1] for c in C1]

                cont = 0
                adj = []

                # Compara com o esqueleto da dimensão anterior (s-1)
                # O esqueleto anterior está em Skel[idx_skel - 1]
                prev_skel_faces = skel[idx_skel - 1]

                for idx_prev, prev_face in enumerate(prev_skel_faces):
                    # Include verifica quantos vértices da face anterior (dim s-1)
                    # estão contidos na nova Face (dim s)

                    npv = include(s, prev_face, s + 1, face)

                    if npv == s:
                        cont += 1
                        adj.append(idx_prev + 1) # 1-based index para o arquivo de saída

                if cont > 0:
                    n_skel[idx_skel] += 1
                    faces_simp.append(face)
                    faces_adj.append(adj)

        skel[idx_skel] = faces_simp
        # AdjSkel armazena adjacência entre (s-1) e s
        adj_skel[idx_skel - 1] = faces_adj

    return n_skel, skel, adj_skel

def marching_simplex(n, k, first, last, division, func, filename):
    first = np.array(first, dtype=float)
    last = np.array(last, dtype=float)
    division = np.array(division, dtype=int)

    delta = (last - first) / division.astype(float)
    pert = np.random.normal(0, 1, (2**n, n)) * 1e-6

    base = init_grid(n, division)

    # permutação inicial: 1..n
    division_p = [i + 1 for i in range(n)]
    base_p = init_grid(n, division_p)

    # combinatória inicial para dimensão k
    division_c = [n - k + i for i in range(1, k + 2)]
    base_c = init_grid(k + 1, division_c)

    with open(filename, "w") as fout:
        fout.write(f"{n:3d} {k:3d}\n")
        fout.write(" ".join(f"{int(d):3d}" for d in division[:n]) + "\n\n")

        # percorre hipercubos
        for g in range(base[n]):
            grid = grid_coords(n, g, base)

            vert, fvert = gen_vert(n, grid, pert, first, delta, func)

            # percorre permutações
            for s in range(base_p[n]):
                print(f"simplexo: g = {g}  s = {s}")

                f = grid_coords(n, s, base_p)
                f1 = [x + 1 for x in f]  # 1-based
                P = map_perm(n, f1)
                simp = gen_label_simplex(n, P)

                vertex_manifold = []
                face_vertex = []
                number_vertex = 0

                # sub-simplexos k-dimensional
                for j in range(base_c[k + 1]):
                    C = grid_coords(k + 1, j, base_c)
                    C1 = [x + 1 for x in C]

                    if lexico(k + 1, C1) == 1:
                        face = [simp[c - 1] for c in C1]
                        vertex, trans = get_vertex_manifold(n, k, face, vert, fvert)

                        if trans == 1:
                            vertex_manifold.append(vertex)
                            face_vertex.append(face)
                            number_vertex += 1

                if number_vertex > 0:
                    n_skel, skel, adj_skel = skeleton(n, simp, k, number_vertex, face_vertex)

                    fout.write(f"{g:3d} ")
                    fout.write(" ".join(f"{int(gi):3d}" for gi in grid) + "\n")
                    fout.write("  1\n")

                    # vértices
                    fout.write(f"{n_skel[0]:3d}\n")
                    for i in range(n_skel[0]):
                        face_line = " ".join(f"{int(x):3d}" for x in skel[0][i])
                        coord_line = " ".join(f"{v:15.8f}" for v in vertex_manifold[i])
                        fout.write(f"{face_line} {coord_line}\n")

                    # adjacência das dimensões superiores
                    for j in range(1, n - k + 1):
                        fout.write(f"{n_skel[j]:3d}\n")
                        if adj_skel[j - 1] is not None:
                            for adj in adj_skel[j - 1]:
                                fout.write(" ".join(f"{int(x):3d}" for x in adj) + "\n")
                    fout.write("\n")

        fout.write("-1\n")

"""# **Variedades implícitas**"""

######### Função toro S^1 x S^1 (codimensão 2) em R^4 ##########

def torus4(n, v):
    return np.array([v[0]**2 + v[1]**2 - 1.0, v[2]**2 + v[3]**2 - 0.25])


if __name__ == "__main__":
    first = np.array([-1.1, -1.1, -0.51, -0.51])
    last = np.array([ 1.1,  1.1,  0.51,  0.51])
    division = np.array([10, 10, 10, 10])
    filename = 'torus4_MS.pol'

    marching_simplex(4, 2, first, last, division, torus4, filename)
    print(f"Gerado: {filename}")

######### Função esfera S^3 em R^4  (codimensão 3 - hipersuperfície) ##########


def esfera4(n, v):

    v_array = np.array(v)
    return np.sum(v_array**2) - 1.0

if __name__ == "__main__":
    first = [-1.1, -1.1, -1.1, -1.1]
    last = [1.1, 1.1, 1.1, 1.1]
    division = [10, 10, 10, 10]
    filename = 'esfera4_MS.pol'



    marching_simplex(4, 1, first, last, division, esfera4, filename)
    print(f"Gerado: {filename}")

############ Função da curva complexa z = cos (w) em R^4 (codimensão 2) ########

def zcosw(n, v):
    term_real = 0.5 * np.exp(-v[1]) * np.cos(v[0]) + 0.5 * np.exp(v[1]) * np.cos(-v[0])
    term_imag = 0.5 * np.exp(-v[1]) * np.sin(v[0]) + 0.5 * np.exp(v[1]) * np.sin(-v[0])
    f1 = v[2] - term_real
    f2 = v[3] - term_imag
    return [f1, f2]


if __name__ == "__main__":
    print("Rodando Curva Complexa z = cos (w)...")
    first   = [-1.0, -np.pi, -4.0, -4.0]
    last     = [ 1.0,  np.pi,  4.0,  4.0]
    division = [12, 12, 12, 12]
    filename = 'complexa_4_MS.pol'



    marching_simplex(4, 2, first, last, division, zcosw, filename)
    print(f"Gerado: {filename}")

####### Aproximação de z^2 = cos(w), com z e w complexo em R^4 #########


def z2cosw(n, x):

    f = np.zeros(2)
    f[0] = (x[2]**2 - x[3]**2) - \
           0.5 * np.exp(-x[1]) * np.cos(x[0]) - \
           0.5 * np.exp(x[1]) * np.cos(-x[0])

    # Parte Imaginária de z^2 - Parte Imaginária de cos(w)
    f[1] = (2.0 * x[2] * x[3]) - \
           0.5 * np.exp(-x[1]) * np.sin(x[0]) - \
           0.5 * np.exp(x[1]) * np.sin(-x[0])

    return f

def complex2():
    first = np.array([-np.pi, -np.pi, -np.pi, -np.pi])
    last = np.array([np.pi, np.pi, np.pi, np.pi])
    division = np.array([10, 10, 10, 10])
    filename = 'z2cosw_MS.pol'

    marching_simplex(4, 2, first, last, division, z2cosw, filename)
    print(f"Arquivo gerado: {filename}")


if __name__ == "__main__":
    complex2()

####### União de oito toros utilizando a normna p, com p = 10 ########

def toro8_p(n, x):

    p = 10.0
    t = np.zeros(8)

    # Toro 1 e 2
    t[0] = np.sqrt((x[0]-6.0)**2 + (x[1]-0.0)**2) - 2.0
    t[1] = np.sqrt((x[0]+6.0)**2 + (x[1]-0.0)**2) - 2.0

    # Toro 3 e 4
    t[2] = np.sqrt((x[0]-0.0)**2 + (x[1]-6.0)**2) - 2.0
    t[3] = np.sqrt((x[0]-0.0)**2 + (x[1]+6.0)**2) - 2.0

    # Toro 5 a 8
    t[4] = np.sqrt((x[0]-4.0)**2 + (x[1]-4.0)**2) - 2.0
    t[5] = np.sqrt((x[0]-4.0)**2 + (x[1]+4.0)**2) - 2.0
    t[6] = np.sqrt((x[0]+4.0)**2 + (x[1]-4.0)**2) - 2.0
    t[7] = np.sqrt((x[0]+4.0)**2 + (x[1]+4.0)**2) - 2.0

    # Acumulador para a norma-p
    val_sum = 0.0
    for i in range(8):
        term = (t[i]**2 + x[2]**2)
        val_sum += term ** (-p)

    f = np.zeros(1)
    f[0] = val_sum ** (-1.0/p) - 1.0

    return f

def oito_toros():
    first = np.array([-9.1, -9.1, -2.1])
    last = np.array([9.1, 9.1, 2.1])
    division = np.array([30, 30, 8])
    filename = 'toro8_10_MS.pol'

    marching_simplex(3, 1, first, last, division, toro8_p, filename)
    print(f"Gerado: {filename}")

if __name__ == "__main__":
    oito_toros()

######## União de esferas com centro em um nó parametrizado, utilizando a norma p, com p = 30 #########

def esfera(x, x0, r):

    dist_sq = (x[0]-x0[0])**2 + (x[1]-x0[1])**2 + (x[2]-x0[2])**2
    return dist_sq - r*r

def parametrizacao(t):
    x0 = np.zeros(3)
    x0[0] = (1.0 + 0.4 * np.cos(1.5*t)) * np.cos(t)
    x0[1] = (1.0 + 0.4 * np.cos(1.5*t)) * np.sin(t)
    x0[2] = 0.5 * np.sin(1.5*t)
    return x0

def no_p(n, x):
    p = 30.0
    m = 150
    r = 0.24

    val_sum = 0.0

    for i in range(m + 1):
        t = 4.0 * np.pi * i / m
        x0 = parametrizacao(t)

        sph_val = esfera(x, x0, r)
        val_sum += (sph_val + 1.0) ** (-p)

    f = np.zeros(1)
    f[0] = val_sum ** (-1.0/p) - 1.0

    return f

def no_de_esferas():
    first = np.array([-1.7, -1.7, -1.1])
    last = np.array([1.7, 1.7, 1.1])
    division = np.array([28, 28, 22])
    filename = 'no_30_MS.pol'

    marching_simplex(3, 1, first, last, division, no_p, filename)
    print(f"Gerado: {filename}")

if __name__ == "__main__":
    no_de_esferas()

